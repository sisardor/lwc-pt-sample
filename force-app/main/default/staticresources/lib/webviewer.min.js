! function(e, t) {
    if ("object" == typeof exports && "object" == typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
      var o = t();
      for (var n in o)("object" == typeof exports ? exports : e)[n] = o[n]
    }
  }(window, (function() {
    return function(e) {
      var t = {};
  
      function o(n) {
        if (t[n]) return t[n].exports;
        var i = t[n] = {
          i: n,
          l: !1,
          exports: {}
        };
        return e[n].call(i.exports, i, i.exports, o), i.l = !0, i.exports
      }
      return o.m = e, o.c = t, o.d = function(e, t, n) {
        o.o(e, t) || Object.defineProperty(e, t, {
          enumerable: !0,
          get: n
        })
      }, o.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
          value: "Module"
        }), Object.defineProperty(e, "__esModule", {
          value: !0
        })
      }, o.t = function(e, t) {
        if (1 & t && (e = o(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var n = Object.create(null);
        if (o.r(n), Object.defineProperty(n, "default", {
            enumerable: !0,
            value: e
          }), 2 & t && "string" != typeof e)
          for (var i in e) o.d(n, i, function(t) {
            return e[t]
          }.bind(null, i));
        return n
      }, o.n = function(e) {
        var t = e && e.__esModule ? function() {
          return e.default
        } : function() {
          return e
        };
        return o.d(t, "a", t), t
      }, o.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
      }, o.p = "/", o(o.s = 0)
    }([function(e, t, o) {
      e.exports = o(1)
    }, function(e, t, o) {
      "use strict";
      o.r(t);
      var n = {};
      "undefined" == typeof console && (window.console = {
        log: function() {},
        warn: function() {},
        error: function() {}
      });
      var i = function() {
          for (var e = 1; e < arguments.length; e++)
            for (var t = Object.keys(arguments[e]), o = 0; o < t.length; o++) arguments[0][t[o]] = arguments[e][t[o]];
          return arguments[0]
        },
        r = function(e, t) {
          var o;
          try {
            o = new CustomEvent(e, {
              detail: t,
              bubbles: !0,
              cancelable: !0
            })
          } catch (n) {
            (o = document.createEvent("Event")).initEvent(e, !0, !0), o.detail = t
          }
          return o
        };
      window.PDFNet && !n.skipPDFNetWebViewerWarning && console.warn("PDFNet.js and WebViewer.js have been included in the same context. See https://www.pdftron.com/kb_same_context for an explanation of why this could be an error in your application.");
      var a = [];
      n.WebViewer = function(e, t) {
        this._validateOptions(e), "legacy" === e.ui && (e.html5Path = "ui-legacy/ReaderControl.html", e.html5MobilePath = "ui-legacy/MobileReaderControl.html", void 0 === e.mobileRedirect && (e.mobileRedirect = !0)), e.fullAPI && e.pdftronServer && (e.forceClientSideInit || console.warn("The fullAPI and pdftronServer options have both been set so the forceClientSideInit option is now enabled. This means that WebViewer will switch to client side rendering and processing to allow use of the full API."), e.forceClientSideInit = !0), this.options = i({}, n.WebViewer.Options, e);
        var o = this.options.path.length - 1;
        o > 0 && "/" !== this.options.path[o] && (this.options.path += "/"), this.options.html5Path = this.options.path + this.options.html5Path, this.options.html5MobilePath = this.options.path + this.options.html5MobilePath, t || console.error("ViewerElement is not defined. This may be caused by calling the WebViewer constructor before the DOM is loaded, or an invalid selector. Please see http://r.pdftron.com/guides/quick-start for an example."), this.element = t, this.element.style.overflow = "hidden";
        var r = this;
        this.messageHandler = function(t) {
          if (t.source === r.iframe.contentWindow && ("requestl" === t.data && t.source.postMessage({
              type: "responsel",
              value: e.l || e.licenseKey
            }, "*"), "requestConfig" === t.data)) {
            var o = e.config ? r._correctRelativePath(e.config) : "";
            t.source.postMessage({
              type: "responseConfig",
              value: o
            }, "*")
          }
        }, window.addEventListener("message", this.messageHandler, !1), this.options.autoCreate && this.create()
      };
      var s = {
        licenseKey: void 0,
        enableAzureWorkaround: !1,
        isAdminUser: !1,
        isReadOnly: !1
      };
      n.WebViewer.prototype = {
        version: "5.1.0",
        create: function() {
          if (this.options.initialDoc) {
            var e = this._correctRelativePath(this.options.initialDoc);
            e = encodeURIComponent(e), this.options.initialDoc = e, this._create()
          } else this._create()
        },
        _create: function() {
          this.rcId = (65536 * (1 + Math.random()) | 0).toString(16).substring(1), void 0 === this._trigger && (this._trigger = function(e, t) {
            var o = r(e, t);
            this.element.dispatchEvent(o)
          });
          var e = this.options.type.replace(" ", "").split(",");
          e.length < 1 && (e[0] = "html5"), this._createViewer(e)
        },
        _validateOptions: function(e) {
          for (var t = Object.keys(e), o = 0; o < t.length; o++) {
            var r = t[o];
            r in i({}, s, n.WebViewer.Options) || console.warn("".concat(r, " is not a valid option name. See http://r.pdftron.com/api/options_anchor for all available options."))
          }!e.enableRedaction || e.fullAPI || e.pdftronServer || console.warn("FullAPI or WebViewer Server is needed to apply redactions")
        },
        _notSupportedMobile: function() {
          var e = document.createElement("div");
          e.id = "webviewer-browser-unsupported", e.textContent = "PDF document viewing is not supported by this browser.", this.element.appendChild(e)
        },
        _createViewer: function(e) {
          var t, o = this;
          if (o.selectedType = null, this.isMobileDevice()) {
            if (this.options.documentType && "xod" !== this.options.documentType && !this._testWebAssembly()) return void this._notSupportedMobile();
            if (e = Array("html5Mobile"), o.selectedType = "html5Mobile", this.options.mobileRedirect) return t = this.options.html5MobilePath + this._getHTML5OptionsURL(), void(window.location = t)
          }
          for (var n = !1, i = !1, r = 0; r < e.length; r++) {
            if ("html5mobile" === e[r].toLowerCase()) {
              if (this.options.documentType && "xod" !== this.options.documentType && !this._testWebAssembly()) continue;
              if (n = !0, o._testHTML5()) {
                if (this.options.mobileRedirect) return o.selectedType = "html5Mobile", t = this.options.html5MobilePath + this._getHTML5OptionsURL(), void(window.location = t);
                if (this.options.xdomainProxyUrl || o.isSameOrigin(decodeURIComponent(o.options.initialDoc)) || o._testCORS()) {
                  o.selectedType = "html5Mobile";
                  break
                }
                i = !0
              }
            }
            if ("html5" === e[r].toLowerCase() && (n = !0, o._testHTML5())) {
              var a = o.isSameOrigin(decodeURIComponent(o.options.initialDoc));
              if (this.options.xdomainProxyUrl || a || o._testCORS()) {
                o.selectedType = "html5";
                break
              }
              i = !0
            }
          }
          if ("html5" === o.selectedType) o._createHTML5();
          else if ("html5Mobile" === o.selectedType) o._createHTML5Mobile();
          else {
            var s;
            if (i ? s = "This browser does not support cross origin requests. Please configure xdomain to support CORS." : n && (s = "Please use an HTML5 compatible browser."), s) {
              var d = document.createElement("div");
              d.id = "webviewer-browser-unsupported", d.textContent = s, o.element.appendChild(d)
            }
          }
        },
        _viewerLoaded: function(e) {
          var t = this;
          t._trigger("ready");
          try {
            var o = e.contentWindow;
            if (void 0 !== t.options.encryption) {
              var n = decodeURIComponent(t.options.initialDoc),
                i = {
                  decrypt: o.CoreControls.Encryption.decrypt,
                  decryptOptions: t.options.encryption,
                  documentId: t.options.documentId
                };
              o.ControlUtils.byteRangeCheck((function(e) {
                200 === e && (i.streaming = !0), t.loadDocument(n, i)
              }), (function() {
                i.streaming = !0, t.loadDocument(n, i)
              }))
            }
            null === t.instance.docViewer.getDocument() ? o.addEventListener("documentLoaded", (function(e) {
              t._trigger(e.type)
            })) : t._trigger("documentLoaded"), ["displayModeChanged", "layoutModeChanged", "zoomChanged", "pageChanged", "fitModeChanged", "toolModeChanged", "rotationChanged", "finishedSavingPDF"].forEach((function(e) {
              o.addEventListener(e, (function(e) {
                t._trigger(e.type, e.detail)
              }))
            }))
          } catch (e) {
            console.warn("Viewer is on a different domain, the promise from WebViewer function is rejected and API functions will not work because of cross domain permissions. See http://r.pdftron.com/kb_cross_origin for more information.")
          }
        },
        _isPDFExtension: function(e) {
          var t = !1;
          if (e) {
            [".pdf", ".png", ".jpg", "jpeg"].forEach((function(o) {
              e === o && (t = !0)
            }))
          }
          return t
        },
        _isOfficeExtension: function(e) {
          var t = !1;
          if (e) {
            [".docx", ".doc", ".pptx"].forEach((function(o) {
              e === o && (t = !0)
            }))
          }
          return t
        },
        _getHTML5OptionsURL: function() {
          "html5" === this.selectedType ? this.options.html5Options && i(this.options, this.options.html5Options) : "html5Mobile" === this.selectedType && this.options.html5MobileOptions && i(this.options, this.options.html5MobileOptions);
          var e, t = this.options,
            o = "";
          if (t.initialDoc && (o += "#d=".concat(t.initialDoc)), "legacy" === t.ui) {
            var n, r = !1,
              a = !1,
              s = t.initialDoc && (n = t.initialDoc.lastIndexOf(".")) ? t.initialDoc.slice(n).toLowerCase() : null;
            ("pdf" === t.documentType || "all" === t.documentType || void 0 === t.documentType && this._isPDFExtension(s)) && (a = !0), ("office" === t.documentType || "all" === t.documentType || void 0 === t.documentType && this._isOfficeExtension(s)) && (r = !0), t.documentType && (o += "&documentType=".concat(t.documentType)), void 0 === t.backendType && (t.backendType = t.pdfBackend),
              function(e, n) {
                e && (o += t.backendType ? "&office=".concat(t.backendType) : "&office=auto"), n && (o += t.backendType ? "&pdf=".concat(t.backendType) : "&pdf=auto")
              }(r, a)
          } else {
            var d, c;
            t.documentType && "xod" === t.documentType && (d = t.documentType), t.preloadWorker && "xod" === t.preloadWorker && (d = t.preloadWorker), t.extension && (d = t.extension), d && (o += "&extension=".concat(d)), t.documentType && "xod" !== t.documentType && (c = t.documentType), t.preloadWorker && "xod" !== t.preloadWorker && (c = t.preloadWorker), c && (o += "&preloadWorker=".concat(c)), t.pdfBackend && (o += "&pdf=".concat(t.pdfBackend, "&office=").concat(t.pdfBackend))
          }
          if (t.filename && (o += "&filename=".concat(t.filename)), t.streaming && (o += "&streaming=".concat(t.streaming)), t.externalPath) {
            var l = this._correctRelativePath(t.externalPath);
            l = encodeURIComponent(l), o += "&p=".concat(l)
          }
          if (t.encryption && (o += "&auto_load=false"), t.enableAnnotations && (o += "&a=1"), t.disabledElements && "legacy" !== t.ui) {
            var u = encodeURIComponent(t.disabledElements.join(","));
            o += "&disabledElements=".concat(u)
          }
          if (t.serverUrl) {
            var h = this._correctRelativePath(t.serverUrl);
            h = encodeURIComponent(h), o += "&server_url=".concat(h)
          }
          if (t.serverUrlHeaders && (o += "&serverUrlHeaders=".concat(JSON.stringify(t.serverUrlHeaders))), t.documentId && (o += "&did=".concat(t.documentId)), t.css) {
            var p = this._correctRelativePath(t.css);
            p = encodeURIComponent(p), o += "&css=".concat(p)
          }
          if ("legacy" === t.ui && t.config) {
            var f = this._correctRelativePath(t.config);
            f = encodeURIComponent(f), o += "&config=".concat(f)
          }(t.disableI18n && "legacy" !== t.ui && (o += "&disableI18n=1"), t.enableOfflineMode && (o += "&offline=1"), t.startOffline && (o += "&startOffline=1"), (t.enableReadOnlyMode || t.isReadOnly) && (o += "&readonly=1"), t.hideAnnotationPanel && (o += "&hideAnnotationPanel=1"), void 0 !== t.annotationUser && (o += "&user=".concat(t.annotationUser)), void 0 === t.annotationAdmin && void 0 === t.isAdminUser || (o += "&admin=".concat(t.annotationAdmin || t.isAdminUser ? 1 : 0)), void 0 !== t.custom && (o += "&custom=".concat(encodeURIComponent(t.custom))), void 0 === t.showLocalFilePicker && void 0 === t.enableFilePicker || (o += "&filepicker=".concat(t.showLocalFilePicker || t.enableFilePicker ? 1 : 0)), "legacy" === t.ui && void 0 !== t.preloadPDFWorker && (o += "&preloadWorker=".concat(t.preloadPDFWorker ? 1 : 0)), void 0 !== t.fullAPI && (o += "&pdfnet=".concat(t.fullAPI ? 1 : 0)), void 0 !== t.enableRedaction && (o += "&enableRedaction=".concat(t.enableRedaction ? 1 : 0)), void 0 !== t.enableMeasurement && (o += "&enableMeasurement=".concat(t.enableMeasurement ? 1 : 0)), void 0 !== t.showToolbarControl && (o += "&toolbar=".concat(t.showToolbarControl ? "true" : "false")), void 0 !== t.showPageHistoryButtons && (o += "&pageHistory=".concat(t.showPageHistoryButtons ? 1 : 0)), void 0 !== t.xdomainProxyUrl) && (e = "string" == typeof t.xdomainProxyUrl ? {
            url: t.xdomainProxyUrl
          } : t.xdomainProxyUrl, o += "&xdomain_urls=".concat(encodeURIComponent(JSON.stringify(e))));
          return (t.azureWorkaround || t.enableAzureWorkaround) && (o += "&azureWorkaround=1"), t.useDownloader || (o += "&useDownloader=0"), t.disableWebsockets && (o += "&disableWebsockets=1"), t.subzero && (o += "&subzero=1"), t.forceClientSideInit && (o += "&forceClientSideInit=1"), void 0 !== t.workerTransportPromise && (o += "&useSharedWorker=".concat(t.workerTransportPromise ? "true" : "false")), void 0 !== t.pdftronServer && t.pdftronServer && (o += "&pdftronServer=".concat(encodeURIComponent(t.pdftronServer))), void 0 !== t.accessibleMode && (o += "&accessibleMode=".concat(t.accessibleMode ? 1 : 0)), o.length > 0 && "&" === o[0] && (o = "#".concat(o.slice(1))), o
        },
        addInstanceData: function(e) {
          a.push({
            iframe: e,
            l: this.options.l || this.options.licenseKey,
            workerTransportPromise: this.options.workerTransportPromise
          })
        },
        _createHTML5: function() {
          var e = this,
            t = this.options.html5Path + this._getHTML5OptionsURL(),
            o = document.createElement("iframe");
          this.addInstanceData(o), o.id = this.rcId, o.src = t, o.title = "webviewer", o.frameBorder = 0, o.width = "100%", o.height = "100%", o.setAttribute("allowfullscreen", !0), o.setAttribute("webkitallowfullscreen", !0), o.setAttribute("mozallowfullscreen", !0), this.iframe = o, this.options.backgroundColor && o.setAttribute("data-bgcolor", this.options.backgroundColor), this.options.assetPath && o.setAttribute("data-assetpath", encodeURIComponent(this.options.assetPath)), this.loadListener = function() {
            var t = e.iframe;
            try {
              e.instance = t.contentWindow.readerControl, void 0 === e.instance ? t.contentWindow.addEventListener("viewerLoaded", (function() {
                e.instance = t.contentWindow.readerControl, e._viewerLoaded(t)
              })) : e._viewerLoaded(t)
            } catch (o) {
              e._viewerLoaded(t)
            }
          }, o.addEventListener("load", this.loadListener), this.element.appendChild(o)
        },
        _createHTML5Mobile: function() {
          var e = this,
            t = this.options.html5MobilePath + this._getHTML5OptionsURL(),
            o = document.createElement("iframe");
          this.addInstanceData(o), o.id = this.rcId, o.src = t, o.frameborder = 0, this.options.assetPath && o.setAttribute("data-assetpath", encodeURIComponent(this.options.assetPath)), o.style.width = "100%", o.style.height = "100%", this.iframe = o, this.loadListener = function() {
            var t = e.iframe;
            try {
              e.instance = t.contentWindow.readerControl, void 0 === e.instance ? t.contentWindow.addEventListener("viewerLoaded", (function() {
                e.instance = t.contentWindow.readerControl, e._viewerLoaded(t)
              })) : e._viewerLoaded(t)
            } catch (o) {
              e._viewerLoaded(t)
            }
          }, o.addEventListener("load", this.loadListener), this.element.appendChild(o)
        },
        dispose: function() {
          var e = this;
          a = a.filter((function(t) {
            return t.iframe !== e.iframe
          })), this.instance.closeDocument(), window.removeEventListener("message", this.messageHandler), this.iframe.removeEventListener("load", this.loadListener), this.iframe = null
        },
        getInstance: function() {
          return this.instance || console.error("The viewer instance is not defined yet. Try calling getInstance() in the ready event listener, or check http://r.pdftron.com/guides/ui/apis for a detailed example."), this.instance
        },
        getSideWindowVisibility: function() {
          return this.getInstance().getShowSideWindow()
        },
        setSideWindowVisibility: function(e) {
          this.getInstance().setShowSideWindow(e)
        },
        getShowSideWindow: function() {
          return this.getSideWindowVisibility()
        },
        setShowSideWindow: function(e) {
          this.setSideWindowVisibility(e)
        },
        getToolbarVisibility: function() {
          console.warn("Unsupported method getToolbarVisibility")
        },
        setToolbarVisibility: function(e) {
          this.getInstance().setToolbarVisibility(e)
        },
        getCurrentPageNumber: function() {
          return this.getInstance().getCurrentPageNumber()
        },
        setCurrentPageNumber: function(e) {
          this.getInstance().setCurrentPageNumber(e)
        },
        getPageCount: function() {
          return this.getInstance().getPageCount()
        },
        getZoomLevel: function() {
          return this.getInstance().getZoomLevel()
        },
        setZoomLevel: function(e) {
          this.getInstance().setZoomLevel(e)
        },
        rotateClockwise: function() {
          this.getInstance().rotateClockwise()
        },
        rotateCounterClockwise: function() {
          this.getInstance().rotateCounterClockwise()
        },
        getLayoutMode: function() {
          var e, t = this.getInstance().getLayoutMode(),
            o = this.iframe.contentWindow.CoreControls.DisplayModes;
          return t === o.Single ? e = n.WebViewer.LayoutMode.Single : t === o.Continuous ? e = n.WebViewer.LayoutMode.Continuous : t === o.Facing ? e = n.WebViewer.LayoutMode.Facing : t === o.FacingContinuous ? e = n.WebViewer.LayoutMode.FacingContinuous : t === o.Cover ? e = n.WebViewer.LayoutMode.FacingCoverContinuous : t === o.CoverFacing && (e = n.WebViewer.LayoutMode.FacingCover), e
        },
        setLayoutMode: function(e) {
          var t = this.iframe.contentWindow.CoreControls.DisplayModes,
            o = t.Continuous;
          e === n.WebViewer.LayoutMode.Single ? o = t.Single : e === n.WebViewer.LayoutMode.Continuous ? o = t.Continuous : e === n.WebViewer.LayoutMode.Facing ? o = t.Facing : e === n.WebViewer.LayoutMode.FacingContinuous ? o = t.FacingContinuous : e === n.WebViewer.LayoutMode.FacingCover ? o = t.CoverFacing : e === n.WebViewer.LayoutMode.FacingCoverContinuous && (o = t.Cover), this.getInstance().setLayoutMode(o)
        },
        getToolMode: function() {
          return this.getInstance().getToolMode()
        },
        setToolMode: function(e) {
          this.getInstance().setToolMode(e)
        },
        fitWidth: function() {
          var e = this.getInstance().docViewer;
          e.setFitMode(e.FitMode.FitWidth)
        },
        fitHeight: function() {},
        fitPage: function() {
          var e = this.getInstance().docViewer;
          e.setFitMode(e.FitMode.FitPage)
        },
        getFitMode: function() {
          var e = this.getInstance().getFitMode(),
            t = this.getInstance().docViewer.FitMode;
          switch (e) {
            case t.FitWidth:
              return n.WebViewer.FitMode.FitWidth;
            case t.FitHeight:
              return n.WebViewer.FitMode.FitHeight;
            case t.FitPage:
              return n.WebViewer.FitMode.FitPage;
            case t.Zoom:
              return n.WebViewer.FitMode.Zoom;
            default:
              console.warn("Unsupported fit mode")
          }
        },
        setFitMode: function(e) {
          e === n.WebViewer.FitMode.FitWidth ? this.fitWidth() : e === n.WebViewer.FitMode.FitHeight ? this.fitHeight() : e === n.WebViewer.FitMode.FitPage ? this.fitPage() : e === n.WebViewer.FitMode.Zoom ? this.zoom() : console.warn("Unsupported fit mode: ".concat(e))
        },
        zoom: function() {
          var e = this.getInstance().docViewer;
          e.setFitMode(e.FitMode.Zoom)
        },
        goToFirstPage: function() {
          this.getInstance().goToFirstPage()
        },
        goToLastPage: function() {
          this.getInstance().goToLastPage()
        },
        goToNextPage: function() {
          this.getInstance().goToNextPage()
        },
        goToPrevPage: function() {
          this.getInstance().goToPrevPage()
        },
        loadDocument: function(e) {
          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            o = {
              streaming: this.options.streaming
            },
            n = i({}, o, t);
          void 0 !== n.documentId && (this.getInstance().docId = n.documentId), this.getInstance().loadDocument(this._correctRelativePath(e), n)
        },
        searchText: function(e, t) {
          var o = 0,
            n = t;
          if ("string" == typeof n && (n = t.split(",")), void 0 !== n)
            for (var i = 0; i < n.length; i++) "CaseSensitive" === n[i] ? o += 1 : "WholeWord" === n[i] ? o += 2 : "SearchUp" === n[i] ? o += 4 : "PageStop" === n[i] ? o += 8 : "ProvideQuads" === n[i] ? o += 16 : "AmbientString" === n[i] && (o += 32);
          void 0 === t ? this.getInstance().searchText(e) : this.getInstance().searchText(e, o)
        },
        setAnnotationUser: function(e) {
          this.getInstance().setAnnotationUser(e)
        },
        setAdminUser: function(e) {
          this.getInstance().setAdminUser(e)
        },
        setReadOnly: function(e) {
          this.getInstance().setReadOnly(e)
        },
        downloadXodDocument: function() {
          if ("xod" === this.documentType) {
            var e = decodeURIComponent(this.options.initialDoc);
            window.open(e)
          } else console.warn("Unsupported method for this document type")
        },
        startPrintJob: function(e) {
          "html5" === this.selectedType ? this.getInstance().startPrintJob(e) : console.warn("Unsupported method startPrintJob")
        },
        endPrintJob: function() {
          "html5" === this.selectedType ? this.getInstance().endPrintJob() : console.warn("Unsupported method endPrintJob")
        },
        getViewerType: function() {
          return this.selectedType
        },
        _correctRelativePath: function(e) {
          if ("string" != typeof e) return e;
          var t = window.location.pathname.substr(0, window.location.pathname.lastIndexOf("/"));
          return /^(\/|%2F|[a-z0-9-]+:)/i.test(e) ? e : "".concat(t, "/").concat(e)
        },
        _testHTML5: function() {
          try {
            var e = document.createElement("canvas");
            return e && e.getContext("2d")
          } catch (e) {
            return !1
          }
        },
        _testWebAssembly: function() {
          return !(!window.WebAssembly || !window.WebAssembly.validate)
        },
        _supports: function(e) {
          if (e === this.selectedType) return !0;
          for (var t = 1; t < arguments.length; t++)
            if (arguments[t] === this.selectedType) return !0;
          return !1
        },
        _testCORS: function() {
          return "XMLHttpRequest" in window && "withCredentials" in new XMLHttpRequest
        },
        isIE: function() {
          var e = navigator.userAgent.toLowerCase(),
            t = /(msie) ([\w.]+)/.exec(e) || /(trident)(?:.*? rv:([\w.]+)|)/.exec(e);
          return t ? parseInt(t[2], 10) : t
        },
        isMobileDevice: function() {
          return !this.isIE() && (0 === this.scrollbarWidth() && navigator.userAgent.match(/Edge/i) || navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/Touch/i) || navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/Silk/i))
        },
        scrollbarWidth: function() {
          var e = document.createElement("div");
          e.style.cssText = "width:100px;height:100px;overflow:scroll !important;position:absolute;top:-9999px", document.body.appendChild(e);
          var t = e.offsetWidth - e.clientWidth;
          return document.body.removeChild(e), t
        },
        isSameOrigin: function(e) {
          var t = window.location,
            o = document.createElement("a");
          o.href = e, "" === o.host && (o.href = o.href);
          var n = window.location.port,
            i = o.port;
          return "http:" === o.protocol ? (i = i || "80", n = n || "80") : "https:" === o.protocol && (i = i || "443", n = n || "443"), o.hostname === t.hostname && o.protocol === t.protocol && i === n
        },
        runInIframe: function(e) {
          var t = this.element.querySelector("iframe").contentWindow,
            o = this,
            n = function n() {
              o.element.removeEventListener("ready", n), e(t, o.getInstance(), t.$)
            };
          this.getInstance() ? setTimeout(n, 0) : this.element.addEventListener("ready", n)
        }
      }, n.WebViewer.Options = {
        initialDoc: void 0,
        annotationAdmin: void 0,
        isAdminUser: void 0,
        annotationUser: void 0,
        assetPath: void 0,
        autoCreate: !0,
        azureWorkaround: !1,
        enableAzureWorkaround: !1,
        backgroundColor: void 0,
        backendType: void 0,
        css: void 0,
        config: void 0,
        custom: void 0,
        documentId: void 0,
        documentType: void 0,
        preloadWorker: void 0,
        extension: void 0,
        enableAnnotations: !0,
        filename: void 0,
        disableI18n: !1,
        disabledElements: void 0,
        disableWebsockets: !1,
        enableOfflineMode: !1,
        enableReadOnlyMode: !1,
        isReadOnly: !1,
        enableRedaction: !1,
        enableMeasurement: !1,
        encryption: void 0,
        externalPath: void 0,
        hideAnnotationPanel: !1,
        html5MobileOptions: {},
        html5MobilePath: "./ui/index.html",
        html5Options: {},
        html5Path: "./ui/index.html",
        l: void 0,
        licenseKey: void 0,
        mobileRedirect: !1,
        path: "",
        pdfBackend: void 0,
        pdftronServer: void 0,
        fullAPI: !1,
        preloadPDFWorker: !0,
        serverUrl: void 0,
        serverUrlHeaders: void 0,
        showLocalFilePicker: !1,
        enableFilePicker: !1,
        showPageHistoryButtons: !0,
        showToolbarControl: void 0,
        startOffline: !1,
        streaming: !1,
        subzero: !0,
        type: "html5,html5Mobile",
        useDownloader: !0,
        workerTransportPromise: void 0,
        xdomainProxyUrl: void 0,
        ui: void 0,
        forceClientSideInit: !1
      }, n.WebViewer.LayoutMode = {
        Continuous: "Continuous",
        FacingCoverContinuous: "CoverContinuous",
        Facing: "Facing",
        FacingContinuous: "FacingContinuous",
        FacingCover: "FacingCover",
        Single: "SinglePage"
      }, n.WebViewer.ToolMode = {
        AnnotationCreateArrow: "AnnotationCreateArrow",
        AnnotationCreateCallout: "AnnotationCreateCallout",
        AnnotationCreateEllipse: "AnnotationCreateEllipse",
        AnnotationCreateFreeHand: "AnnotationCreateFreeHand",
        AnnotationCreateFreeText: "AnnotationCreateFreeText",
        AnnotationCreateLine: "AnnotationCreateLine",
        AnnotationCreatePolygon: "AnnotationCreatePolygon",
        AnnotationCreatePolygonCloud: "AnnotationCreatePolygonCloud",
        AnnotationCreatePolyline: "AnnotationCreatePolyline",
        AnnotationCreateRectangle: "AnnotationCreateRectangle",
        AnnotationCreateSignature: "AnnotationCreateSignature",
        AnnotationCreateStamp: "AnnotationCreateStamp",
        AnnotationCreateSticky: "AnnotationCreateSticky",
        AnnotationCreateTextHighlight: "AnnotationCreateTextHighlight",
        AnnotationCreateTextSquiggly: "AnnotationCreateTextSquiggly",
        AnnotationCreateTextStrikeout: "AnnotationCreateTextStrikeout",
        AnnotationCreateTextUnderline: "AnnotationCreateTextUnderline",
        AnnotationEdit: "AnnotationEdit"
      }, n.WebViewer.FitMode = {
        FitHeight: "FitHeight",
        FitPage: "FitPage",
        FitWidth: "FitWidth",
        Zoom: "Zoom"
      }, n.WebViewer.SearchMode = {
        CaseSensitive: 1,
        WholeWord: 2,
        SearchUp: 4,
        PageStop: 8,
        ProvideQuads: 16,
        AmbientString: 32
      }, n.WebViewer.User = function(e, t, o) {
        this.username = e, this.isAdmin = void 0 !== t && t, this.isReadOnly = void 0 !== o && o
      };
      var d = function(e, t) {
          return new Promise((function(o, r) {
            e.l = e.l || e.licenseKey, e.azureWorkaround = e.azureWorkaround || e.enableAzureWorkaround, e.annotationAdmin = e.annotationAdmin || e.isAdminUser, e.enableReadOnlyMode = e.enableReadOnlyMode || e.isReadOnly, e.showLocalFilePicker = e.showLocalFilePicker || e.enableFilePicker;
            var a = new n.WebViewer(e, t);
            t.addEventListener("ready", (function e() {
              t.removeEventListener("ready", e);
              try {
                var n = t.querySelector("iframe").contentWindow,
                  s = n.Tools;
                if (void 0 === s) return r("Viewer isn't instantiated correctly. It could be caused by the 'path' option in the WebViewer constructor not being defined correctly. The 'path' option should be relative to the HTML file you're loading the script on and the lib folder needs to be publicly accessible.");
                var d = a.getInstance();
                o(i({}, d, {
                  dispose: a.dispose.bind(a),
                  Tools: s,
                  Annotations: n.Annotations,
                  CoreControls: n.CoreControls,
                  PartRetrievers: n.CoreControls.PartRetrievers,
                  Actions: n.Actions,
                  PDFNet: n.PDFNet,
                  annotManager: d.docViewer.getAnnotationManager(),
                  docViewer: d.docViewer,
                  iframeWindow: n
                }))
              } catch (e) {
                r("Viewer is on a different domain, the promise from WebViewer function is rejected and API functions will not work because of cross domain permissions. See https://www.pdftron.com/kb_cross_origin for more information.")
              }
            }))
          }))
        },
        c = function(e) {
          return a.filter((function(t) {
            return t.iframe === e
          }))[0]
        };
      d.l = function(e) {
        var t = c(e);
        return t && t.l
      }, d.workerTransportPromise = function(e) {
        var t = c(e);
        return t && t.workerTransportPromise
      }, window.PDFTron = n, window.WebViewer = d, t.default = d
    }])
  }));